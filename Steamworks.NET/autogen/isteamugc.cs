// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2014 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

using System;
using System.Runtime.InteropServices;

namespace Steamworks {
	public static class SteamUGC {
		/// <summary>
		/// <para> Query UGC associated with a user. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.</para>
		/// </summary>
		public static UGCQueryHandle_t CreateQueryUserUGCRequest(AccountID_t unAccountID, EUserUGCList eListType, EUGCMatchingUGCType eMatchingUGCType, EUserUGCListSortOrder eSortOrder, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint unPage) {
			InteropHelp.TestIfAvailableClient();
			return (UGCQueryHandle_t)NativeMethods.ISteamUGC_CreateQueryUserUGCRequest(unAccountID, eListType, eMatchingUGCType, eSortOrder, nCreatorAppID, nConsumerAppID, unPage);
		}

		/// <summary>
		/// <para> Query for all matching UGC. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.</para>
		/// </summary>
		public static UGCQueryHandle_t CreateQueryAllUGCRequest(EUGCQuery eQueryType, EUGCMatchingUGCType eMatchingeMatchingUGCTypeFileType, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint unPage) {
			InteropHelp.TestIfAvailableClient();
			return (UGCQueryHandle_t)NativeMethods.ISteamUGC_CreateQueryAllUGCRequest(eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, unPage);
		}

		/// <summary>
		/// <para> Send the query to Steam</para>
		/// </summary>
		public static SteamAPICall_t SendQueryUGCRequest(UGCQueryHandle_t handle) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_SendQueryUGCRequest(handle);
		}

		/// <summary>
		/// <para> Retrieve an individual result after receiving the callback for querying UGC</para>
		/// </summary>
		public static bool GetQueryUGCResult(UGCQueryHandle_t handle, uint index, out SteamUGCDetails_t pDetails) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_GetQueryUGCResult(handle, index, out pDetails);
		}

		/// <summary>
		/// <para> Release the request to free up memory, after retrieving results</para>
		/// </summary>
		public static bool ReleaseQueryUGCRequest(UGCQueryHandle_t handle) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_ReleaseQueryUGCRequest(handle);
		}

		/// <summary>
		/// <para> Options to set for querying UGC</para>
		/// </summary>
		public static bool AddRequiredTag(UGCQueryHandle_t handle, string pTagName) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_AddRequiredTag(handle, pTagName);
		}

		public static bool AddExcludedTag(UGCQueryHandle_t handle, string pTagName) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_AddExcludedTag(handle, pTagName);
		}

		public static bool SetReturnLongDescription(UGCQueryHandle_t handle, bool bReturnLongDescription) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetReturnLongDescription(handle, bReturnLongDescription);
		}

		public static bool SetReturnTotalOnly(UGCQueryHandle_t handle, bool bReturnTotalOnly) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetReturnTotalOnly(handle, bReturnTotalOnly);
		}

		public static bool SetAllowCachedResponse(UGCQueryHandle_t handle, uint unMaxAgeSeconds) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetAllowCachedResponse(handle, unMaxAgeSeconds);
		}

		/// <summary>
		/// <para> Options only for querying user UGC</para>
		/// </summary>
		public static bool SetCloudFileNameFilter(UGCQueryHandle_t handle, string pMatchCloudFileName) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetCloudFileNameFilter(handle, pMatchCloudFileName);
		}

		/// <summary>
		/// <para> Options only for querying all UGC</para>
		/// </summary>
		public static bool SetMatchAnyTag(UGCQueryHandle_t handle, bool bMatchAnyTag) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetMatchAnyTag(handle, bMatchAnyTag);
		}

		public static bool SetSearchText(UGCQueryHandle_t handle, string pSearchText) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetSearchText(handle, pSearchText);
		}

		public static bool SetRankedByTrendDays(UGCQueryHandle_t handle, uint unDays) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetRankedByTrendDays(handle, unDays);
		}

		/// <summary>
		/// <para> Request full details for one piece of UGC</para>
		/// </summary>
		public static SteamAPICall_t RequestUGCDetails(PublishedFileId_t nPublishedFileID, uint unMaxAgeSeconds) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_RequestUGCDetails(nPublishedFileID, unMaxAgeSeconds);
		}

		/// <summary>
		/// <para> Steam Workshop Creator API</para>
		/// <para> create new item for this app with no content attached yet</para>
		/// </summary>
		public static SteamAPICall_t CreateItem(AppId_t nConsumerAppId, EWorkshopFileType eFileType) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_CreateItem(nConsumerAppId, eFileType);
		}

		/// <summary>
		/// <para> start an UGC item update. Set changed properties before commiting update with CommitItemUpdate()</para>
		/// </summary>
		public static UGCUpdateHandle_t StartItemUpdate(AppId_t nConsumerAppId, PublishedFileId_t nPublishedFileID) {
			InteropHelp.TestIfAvailableClient();
			return (UGCUpdateHandle_t)NativeMethods.ISteamUGC_StartItemUpdate(nConsumerAppId, nPublishedFileID);
		}

		/// <summary>
		/// <para> change the title of an UGC item</para>
		/// </summary>
		public static bool SetItemTitle(UGCUpdateHandle_t handle, string pchTitle) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemTitle(handle, pchTitle);
		}

		/// <summary>
		/// <para> change the description of an UGC item</para>
		/// </summary>
		public static bool SetItemDescription(UGCUpdateHandle_t handle, string pchDescription) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemDescription(handle, pchDescription);
		}

		/// <summary>
		/// <para> change the visibility of an UGC item</para>
		/// </summary>
		public static bool SetItemVisibility(UGCUpdateHandle_t handle, ERemoteStoragePublishedFileVisibility eVisibility) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemVisibility(handle, eVisibility);
		}

		/// <summary>
		/// <para> change the tags of an UGC item</para>
		/// </summary>
		public static bool SetItemTags(UGCUpdateHandle_t updateHandle, System.Collections.Generic.IList<string> pTags) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemTags(updateHandle, new InteropHelp.SteamParamStringArray(pTags));
		}

		/// <summary>
		/// <para> update item content from this local folder</para>
		/// </summary>
		public static bool SetItemContent(UGCUpdateHandle_t handle, string pszContentFolder) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemContent(handle, pszContentFolder);
		}

		/// <summary>
		/// <para>  change preview image file for this item. pszPreviewFile points to local image file</para>
		/// </summary>
		public static bool SetItemPreview(UGCUpdateHandle_t handle, string pszPreviewFile) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_SetItemPreview(handle, pszPreviewFile);
		}

		/// <summary>
		/// <para> commit update process started with StartItemUpdate()</para>
		/// </summary>
		public static SteamAPICall_t SubmitItemUpdate(UGCUpdateHandle_t handle, string pchChangeNote) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_SubmitItemUpdate(handle, pchChangeNote);
		}

		public static EItemUpdateStatus GetItemUpdateProgress(UGCUpdateHandle_t handle, out ulong punBytesProcessed, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_GetItemUpdateProgress(handle, out punBytesProcessed, out punBytesTotal);
		}

		/// <summary>
		/// <para> Steam Workshop Consumer API</para>
		/// <para> subscript to this item, will be installed ASAP</para>
		/// </summary>
		public static SteamAPICall_t SubscribeItem(PublishedFileId_t nPublishedFileID) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_SubscribeItem(nPublishedFileID);
		}

		/// <summary>
		/// <para> unsubscribe from this item, will be uninstalled after game quits</para>
		/// </summary>
		public static SteamAPICall_t UnsubscribeItem(PublishedFileId_t nPublishedFileID) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamUGC_UnsubscribeItem(nPublishedFileID);
		}

		/// <summary>
		/// <para> number of subscribed items</para>
		/// </summary>
		public static uint GetNumSubscribedItems() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_GetNumSubscribedItems();
		}

		/// <summary>
		/// <para> all subscribed item PublishFileIDs</para>
		/// </summary>
		public static uint GetSubscribedItems(PublishedFileId_t[] pvecPublishedFileID, uint cMaxEntries) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_GetSubscribedItems(pvecPublishedFileID, cMaxEntries);
		}

		/// <summary>
		/// <para> Get info about the item on disk.  If you are supporting items published through the legacy RemoteStorage APIs then *pbLegacyItem will be set to true</para>
		/// <para> and pchFolder will contain the full path to the file rather than the containing folder.</para>
		/// <para> returns true if item is installed</para>
		/// </summary>
		public static bool GetItemInstallInfo(PublishedFileId_t nPublishedFileID, out ulong punSizeOnDisk, out string pchFolder, uint cchFolderSize, out bool pbLegacyItem) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchFolder2 = Marshal.AllocHGlobal((int)cchFolderSize);
			bool ret = NativeMethods.ISteamUGC_GetItemInstallInfo(nPublishedFileID, out punSizeOnDisk, pchFolder2, cchFolderSize, out pbLegacyItem);
			pchFolder = ret ? InteropHelp.PtrToStringUTF8(pchFolder2) : null;
			Marshal.FreeHGlobal(pchFolder2);
			return ret;
		}

		public static bool GetItemUpdateInfo(PublishedFileId_t nPublishedFileID, out bool pbNeedsUpdate, out bool pbIsDownloading, out ulong punBytesDownloaded, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamUGC_GetItemUpdateInfo(nPublishedFileID, out pbNeedsUpdate, out pbIsDownloading, out punBytesDownloaded, out punBytesTotal);
		}
	}
}